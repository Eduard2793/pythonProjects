import matplotlib.pyplot as plt
import mpl_toolkits.mplot3d as p3
import numpy as np
import random
import time

from functools import partial
from ipywidgets import interact, RadioButtons, IntSlider, FloatSlider, Dropdown, BoundedFloatText
from numpy.linalg import norm


class Perceptron:

    def __init__(self, w, b):
        """
        Инициализируем наш объект - перцептрон.
        w - вектор весов размера (m, 1), где m - количество переменных
        b - число
        """
        
        self.w = w
        self.b = b

    def forward_pass(self, single_input):
        """
        Метод рассчитывает ответ перцептрона при предъявлении одного примера
        single_input - вектор примера размера (m, 1).
        Метод возвращает число (0 или 1) или boolean (True/False)
        """
        '''
        return int((self.w.T.dot(single_input)+self.b)>0) # ===========================тоже пойдет
        '''
        result = 0
        for i in range(0, len(self.w)):
            result += self.w[i] * single_input[i]
        result += self.b
        
        if result > 0:
            return 1
        else:
            return 0

    def vectorized_forward_pass(self, input_matrix):
        """
        Метод рассчитывает ответ перцептрона при предъявлении набора примеров
        input_matrix - матрица примеров размера (n, m), каждая строка - отдельный пример,
        n - количество примеров, m - количество переменных
        Возвращает вертикальный вектор размера (n, 1) с ответами перцептрона
        (элементы вектора - boolean или целые числа (0 или 1))
        """
        #=================================реализован1
        """ alternative
        z = input_matrix.dot(self.w)+self.b
        y = []
        for i in range(0,len(z)):
            if z[i] > 0:
               y.append(1)
            else:
               y.append(0)
            
        return np.array(y).reshape(len(y),1)
        """
        y = []
        for i in range(0,len(input_matrix)):
            y.append(self.forward_pass(input_matrix[i]))
        return np.array(y).reshape(len(y),1)
    #=================================реализован1
        
    def train_on_single_example(self, example, y):
        """
        принимает вектор активации входов example формы (m, 1) 
        и правильный ответ для него (число 0 или 1 или boolean),
        обновляет значения весов перцептрона в соответствии с этим примером
        и возвращает размер ошибки, которая случилась на этом примере до изменения весов (0 или 1)
        (на её основании мы потом построим интересный график)
        """
        #=================================реализован2
        ym = self.forward_pass(example)
        e = y - ym
        self.w = self.w + e*example
        self.b = self.b + e
        return e
    #=================================реализован2
